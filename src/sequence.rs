/// Unpack a u32 into a sequence of {0,1} u8
/// This function is meant to provide seed/initialisation values for sequences commonly
/// generated by linear-shift registers.
/// Such sequences/tap configurations are commonly used for scrambling or correlation purposes
/// __Example__
/// ```
/// use aether_primitives::sequence;
/// let seed = 1u32 + 4u32 + 16u32;
/// let expanded = sequence::expand(seed);
/// let mut expected = vec![0u8; 32];
/// expected.iter_mut().zip([1,0,1,0,1].iter())
///     .for_each(|(s,x)| *s = *x as u8);
///
/// assert_eq!(expanded, expected, "Seed expansion failed");
/// assert_eq!(expanded.len(), 32usize)
/// ```
pub fn expand(seed : u32) -> Vec<u8>{
    // left shift seed value and use binary & to extract the bit we're interested in
    (0..32).map(|i| (seed >> i & 1) as u8).collect()
}

/// Generate a sequence based on initial values and a number of taps
/// ```seed``` : 
/// ```generator```: a function that generates elements,
/// may rely on values currently within the sequence,
// is also provided the current position to be filled by the new value
/// ```len``` : length of the 
/// __Example__
/// ```
/// use aether_primitives::sequence;
///
///
/// unimplemented!();
/// ```
pub fn generate(seed : Vec<u8>, generator : impl Fn(usize,&[u8]) -> u8, len : usize) -> Vec<u8>{
    unimplemented!()
}

#[cfg(test)]
mod test{
    use crate::sequence;

}